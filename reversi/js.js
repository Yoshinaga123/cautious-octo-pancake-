/*そもそもJavaScriptってなに？
主にWebBrowserで動くプログラミング言語です。 
ウェブサイトで操作をしたら表示が書き換わったり、ウェブサイトのサーバーと通信してデータを取得したりと
現在のウェブサイトには欠かせないプログラミング言語です。
Node.jsというサーバー側で動いたり、
デスクトップアプリやスマートフォンアプリ、IoTデバイスなど幅広い環境で使用される。
*/

//ECMScriptは、ES2015に大きなアップデートがあった。
//そこを基準に学習するが既存コードはES2015以前のものが多い。

//大文字小文字を区別する

const name = "azu";
const NAME = "azu";

//予約語を持つ
//文末は必ず;を記述する。自動挿入はされる。

//文の間の空白に関してコーディングルールがある可能性あるので準拠する
//空白文字は動作に影響しない

1 + 1;
1   +   1;

/*JavaScriptにはstrict modeという実行モードが存在しています。
名前のとおり厳格な実行モードで、古く安全でない構文や機能が一部禁止されています。
"use strict"という文字列をファイルまたは関数の先頭に書くことで、 
そのスコープにあるコードはstrict modeで実行されます。
また、後述する"Module"の実行コンテキストでは、
このstrict modeがデフォルトとなっています。
*/

"use strict";// このコードはstrict modeで実行される

//strict modeでは、evalやwithといったレガシーな機能や構文を禁止します。 
//eval is evilの例

// let x = 10; // ← 既に下で 'let x;' があるのでコメントアウトまたは削除
let yy = 20;
let codeString = "x + yy";

let result = eval(codeString); // "x + y" という文字列をコードとして実行する

console.log(result); // 30 と表示される

//オブジェクト
let user = {
  name: "Alice",
  age: 30,
  address: {
    city: "Tokyo"
  }
};

// withを使わない場合
console.log(user.name);
console.log(user.age);

// withを使った場合
with (user) {
  console.log(name);  // user.name のこと
  console.log(age);   // user.age のこと
}
// withは、オブジェクトのプロパティを直接参照できるようにするが、
// 可読性が低下し、バグの原因になる可能性があるため 
// strict modeでは禁止されている。
// strict modeでは、変数の再宣言や未定義の変数への代入も禁止されます。
// 例えば、以下のようなコードはstrict modeではエラーになります。 
let x2 = 10;
// let x2 = 20; // エラー: 変数 'x2' はすでに宣言されています  
let y1; // エラー: 変数 'y' は未定義です
y = 30; // エラー: 変数 'y' は未定義  
// strict modeでは、関数の引数の名前を重複させることも禁止されています。
function example(a, a) { // エラー: 引数 'a' はすでに宣言されています
  console.log(a);
}

"use strict";
mistypedVariable = 42; // => ReferenceError


//JavaScriptのコードは、HTMLの中に直接書くこともできます。
//例えば、以下のようにHTMLの中にscriptタグを使ってJavaScriptコードを書くことができます。


// <script language="javascript">
//   document.bgColor = "brown";
// </script>


// Script非対応のブラウザでは、スクリプトタグは認識されず、中の処理もコメントアウトとなりすべて無視される。
// 一方で、JavaScriptをサポートしているブラウザでは、scriptタグ内のコメントアウトは無視され、実行される
// 現在は、すべてのブラウザがJavaScriptをサポートしているため、
// scriptタグ内のコードは実行されます。

// 一方、<script>タグ内、つまりJavaScript内にHTMLコメントが書かれているサイトは残っています。 
// このようなサイトでもJavaScriptが動作するという、後方互換性のための仕様として追加されています。

// HTML-likeなコメントは、後方互換性のためだけに存在する。

// そのため、現在のJavaScriptでは、HTML-likeなコメントは使用しないことが推奨されています。

//　文字列や数値などのデータに名前を付けることで、くり返し使用できるようにすることを変数といいます。
//　変数宣言のキーワードは三つある。
// var, let, const
// varは、古いJavaScriptのバージョンから存在する変数宣言のキーワードで、
//　意図しない動作を引き起こしやすい問題がある。
//  varは、初期化がホイスティングされない、

const bookTitle = "JavaScriptの基礎"; // 定数の宣言
const bookcategory = "プログラミング"; // 定数の宣言

const bookTitle1 = "JavaScript Primer";
bookTitle1 = "新しいタイトル"; // エラー: 定数は再代入できない

let bookTitlee = "JavaScriptの基礎"; // 変数の宣言
bookTitle = "新しいタイトル"; // 変数は再代入可能

let bookTitle3;// undefined


let count = 0;
count = 1;
count = 2;
count = 3;

// "x"という変数名で変数を定義する
let x;
// 同じ名前の変数"x"を定義するとSyntaxErrorとなる
// let x; // => SyntaxError: redeclaration of let x

// varの問題は、同じ名前の変数を再定義できてしまうことです。
var y = 10;
var y = 20; // これは許可される
// そのため、意図しない変数の再定義や上書きが発生する可能性があります。
// これに対して、letとconstは同じ名前の変数を再定義できません。
let z = 10;
// let z = 20; // これは許可されない

// 変数のスコープ（有効範囲）も異なります。
// varは関数スコープを持ち、関数内で宣言された変数はその関数内でのみ有効です。
function example() {
  var a = 10; // 関数スコープ
  console.log(a); // 10
}

let $; // OK: $が利用できる
let _title; // OK: _が利用できる
let jquery; // OK: 小文字のアルファベットが利用できる
let TITLE; // OK: 大文字のアルファベットが利用できる
let es2015; // OK: 数字は先頭以外なら利用できる
let 日本語の変数名; // OK: 一部の漢字や日本語も利用できる

// let 1st; // NG: 数字から始まっている
let first; // OK: アルファベットから始まっている
// let 123; // NG: 数字のみで構成されている（エラーになるためコメントアウト）

// let let; // NG: `let`は変数宣言のために予約されているので利用できない
// let if; // NG: `if`はif文のために予約されているので利用できない

console.log(Number.MAX_SAFE_INTEGER); 
// 最大の安全な整数値を表示する
console.log(Number.MIN_SAFE_INTEGER); 
// 最小の安全な整数値を表示する

console.log(1n); // => 1n
// 2^53-1より大きな値も扱える
console.log(9007199254740992n); // => 9007199254740992n

// BigIntは、整数値を表すための新しいデータ型で、
// JavaScriptのNumber型では表現できない大きな整数値を扱う

// この問題を解決するために、ES2020ではBigIntという新しい整数型のデータ型とリテラルが追加されました。 
// 数値リテラルは倍精度浮動小数（64ビット）で数値を扱うのに対して、BigIntでは任意の精度の整数を扱えます。 
// そのため、BigIntでは2^53-1（9007199254740991）よりも大きな整数を正しく表現できます。

// BigIntリテラルは、数値の後ろにnをつけます。

let bigIntValue = 1234567890123456789012345678901234567890n; // BigIntリテラル
console.log(bigIntValue); // 1234567890123456789012345678901234567890n 

console.log(1n); // => 1n
// 2^53-1より大きな値も扱える
console.log(9007199254740992n); // => 9007199254740992n

// BigIntは整数を扱うデータ型であるため、次のように小数点を含めた場合は構文エラーとなります。

// 1.2n; // => SyntaxError

// BigIntは整数を扱うため、浮動小数点数を含むリテラルは構文エラーとなります。
// let floatValue = 1.2n; // => SyntaxError: Invalid or unexpected token

// ES2021から、数値リテラル内の区切り文字として_を追加できるNumeric Separatorsがサポートされています。 
// Numeric Separatorsは、数値リテラル内では区切り文字として_が追加できます。 次のコードも、1兆を数値リテラルで書いています。
// 数値リテラルを評価する際に_は単純に無視されるため同じ意味となります。

1_000_000_000_000;

// 1_000_000_000_000は、1兆を表す数値リテラルです。
// これは、1兆を表すために数値リテラル内で _を使用して区切り文字を追加しています。

// これにより、数値リテラルが読みやすくなります。

// Numeric Separatorsは数値リテラルである整数、浮動小数点、BigIntのリテラル内でのみ利用できます。 また、_はリテラルの先頭や数値の最後に追加することはできません。

_123; // 変数として評価される
// 3._14; // => SyntaxError
// 0x52_; // => SyntaxError
// 1234n_; // => SyntaxError

1_2_34; // => SyntaxError
// 1_2_34は、数値リテラルとしては無効 です。
// 数値リテラル内での_の使用は、数値の区切り文字としてのみ機能します。
// そのため、1_2_34は無効な数値リテラルとなります。
12_34; // => SyntaxError
// 12_34も同様に無効な数値リテラルです
// 0を区切る目的でしか_は使用できません。

// 文字列リテラル共通のルールとして、同じ記号で囲んだ内容を文字列として扱います。 文字列リテラルとして次の3種類のリテラルがありますが、その評価結果はすべて同じ"文字列"になります。

// console.log("文字列"); // => "文字列"
// console.log('文字列　'); // => "文字列"
// console.log(`文字列`); // => "文字列"

// 文字列リテラルは、文字列を表すためのリテラルで、
// 文字列は、文字の並びを表現するためのデータ型

// "（ダブルクォート）と'（シングルクォート）はまったく同じ意味となります。 PHPやRubyなどとは違い、どちらのリテラルでも評価結果は同じとなります。

// 文字列リテラルは同じ記号で囲む必要があるため、次のように文字列の中に同じ記号が出現した場合は、 \'のように\（バックスラッシュ）を使ってエスケープしなければなりません。

'8 o\'clock'; // => "8 o'clock"
// "8 o'clock"という文字列を表すために、'（シングルクォート）で囲み、
// その中に'（シングルクォート）が含まれているため
// その部分を\'とエスケープしています。 これにより、文字列リテラル内でのシングルクォートの使用が可能になります。

// ダブルクォートとシングルクォートどちらも、改行をそのままでは入力できません。 次のように改行を含んだ文字列は定義できないため、構文エラー（SyntaxError）となります。

// "複数行の
// 文字列を
// 入れたい"; // => SyntaxError: "" string literal contains an unescaped line break

// 改行の代わりに改行記号のエスケープシーケンス（\n）を使うことで複数行の文字列を書くことができます。

// "複数行の\n文字列を\n入れたい";

// また、名前のとおりテンプレートのような機能も持っています。 テンプレートリテラル内で${変数名}と書いた場合に、その変数の値を埋め込むことができます。

const str = "文字列";
console.log(`これは${str}です`); // => "これは文字列です"

// テンプレートリテラルは、バッククォート（`）で囲まれた文字列で、
// 文字列の中に変数や式を埋め込むことができます。
// そのため、文字列の中に変数や式を埋め込むことができるため、文字列の組み立てが簡単になります。

// nullリテラルはnull値を返すリテラルです。 nullは「値がない」ということを表現する値です。

// 次のように、未定義の変数を参照した場合は、 参照できないためReferenceErrorの例外が投げられます。

foo;// "ReferenceError: foo is not defined"

// 変数fooは宣言されていないため、参照できません。 そのため、ReferenceErrorが発生します。

// fooには値がないということを表現したい場合は、 null値を代入することで、null値を持つfooという変数を定義できます。 これにより、fooを値がない変数として定義し、参照できるようになります。

const foo = null;
console.log(foo); // => nul

// nullは、値がないことを明示的に示すための値であり、
// 変数が存在するが値がないことを示すために使用されます。

// プリミティブ型として紹介したundefinedはリテラルではありません。 undefinedはただのグローバル変数で、undefinedという値を持っているだけです。

// 次のように、undefinedはただのグローバル変数であるため、同じundefinedという名前のローカル変数を宣言できます。

function fn(){
    const undefined = "独自の未定義値"; // undefinedという名前の変数をエラーなく定義できる
    console.log(undefined); // => "独自の未定義値"
}
fn();
