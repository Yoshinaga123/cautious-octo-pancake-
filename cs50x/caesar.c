// ===== シーザー暗号プログラム =====
// このプログラムは、古代ローマのユリウス・カエサル（シーザー）が使用したとされる
// 暗号化方式を実装したものです。アルファベットを指定した数だけずらして暗号化します。

// ===== ヘッダーファイルのインクルード =====
#include <cs50.h>      // CS50ライブラリ（string型、get_string関数など）
#include <ctype.h>     // 文字判定関数（isdigit, isalpha, isupper など）
#include <stdio.h>     // 標準入出力関数（printf など）
#include <stdlib.h>    // 標準ライブラリ関数（atoi など）
#include <string.h>    // 文字列操作関数（strlen など）

// ===== プロトタイプ宣言（関数の前方宣言） =====
// C言語では、関数を使用する前にその存在を宣言する必要がある
// 実際の関数定義は後で行う
bool only_digits(string s);    // 文字列が数字のみかチェックする関数
char rotate(char c, int n);    // 文字を回転（暗号化）する関数

// ===== メイン関数 =====
// プログラムの実行開始点
// argc: コマンドライン引数の数, argv: コマンドライン引数の配列
int main(int argc, string argv[])
{
    // ===== 1. コマンドライン引数の検証 =====
    // ./caesar 3 のように実行された場合、argc=2（プログラム名+引数1個）になる
    // argc != 2 は引数が1個でないことを意味する
    if (argc != 2)
    {
        printf("Usage: ./caesar key\n");
        return 1; // エラーコード1で終了（0以外は異常終了を表す）
    }

    // ===== 2. 引数の内容検証 =====
    // 引数（鍵）がすべて数字で構成されているかチェック
    // only_digits関数を使用（自作の関数）
    // !only_digits(argv[1]) は「数字以外が含まれている」という意味
    if (!only_digits(argv[1]))
    {
        printf("Usage: ./caesar key\n");
        return 1; // 無効な鍵の場合はエラー終了
    }

    // ===== 3. 文字列から整数への変換 =====
    // atoi関数: ASCII to Integer（文字列を整数に変換）
    // 例: "13" → 13
    int key = atoi(argv[1]);

    // ===== 4. ユーザー入力の取得 =====
    // get_string関数: ユーザーから文字列を取得（CS50ライブラリ）
    string plaintext = get_string("plaintext:  ");

    // ===== 5. 暗号化処理の開始 =====
    printf("ciphertext: ");

    // ===== 6. 各文字の暗号化ループ =====
    // for文の構造: for(初期化; 条件; 更新)
    // strlen(plaintext): 文字列の長さを取得
    // 効率化のため、lengthを変数lenに保存（毎回計算する必要がない）
    for (int i = 0, len = strlen(plaintext); i < len; i++)
    {
        // rotate関数で文字を暗号化
        // plaintext[i]: i番目の文字を取得
        char rotated_char = rotate(plaintext[i], key);
        
        // 暗号化された文字を出力
        printf("%c", rotated_char);
    }

    // ===== 7. 出力の完了 =====
    printf("\n"); // 改行を出力（見やすさのため）

    return 0; // 正常終了（0は成功を表す）
}

// ===== 数字判定関数 =====
/**
 * @brief 文字列がすべて数字で構成されているかチェックする関数
 * @param s 検証する文字列
 * @return すべて数字の場合true、そうでなければfalse
 * 
 * この関数の目的:
 * - コマンドライン引数として渡された鍵が有効な数値かチェック
 * - 例: "123" → true, "12a" → false, "" → true（空文字列は全て数字とみなす）
 */
bool only_digits(string s)
{
    // 文字列の各文字を順番にチェック
    for (int i = 0, len = strlen(s); i < len; i++)
    {
        // isdigit関数: 文字が数字（0-9）かどうか判定
        // !isdigit(s[i]): 数字でない文字が見つかった場合
        if (!isdigit(s[i]))
        {
            return false; // 一つでも数字以外があればfalseを返す
        }
    }
    return true; // 全ての文字が数字の場合はtrueを返す
}

// ===== 文字回転（暗号化）関数 =====
/**
 * @brief シーザー暗号で文字を回転させる関数
 * @param c 暗号化する文字
 * @param n 回転させる数（鍵の値）
 * @return 暗号化された文字
 * 
 * シーザー暗号の仕組み:
 * - アルファベットを環状に並べて考える（A→B→...→Z→A...）
 * - 各文字を鍵の数だけ右にずらす
 * - 例: 鍵が3の場合、A→D, B→E, ..., X→A, Y→B, Z→C
 */
char rotate(char c, int n)
{
    // ===== アルファベット以外の文字の処理 =====
    // isalpha関数: 文字がアルファベット（a-z, A-Z）かどうか判定
    // アルファベット以外（数字、記号、スペースなど）はそのまま返す
    if (!isalpha(c))
    {
        return c; // 暗号化せずにそのまま返す
    }

    // ===== 大文字・小文字の判定と基準文字の設定 =====
    // isupper関数: 大文字かどうか判定
    // 三項演算子: 条件 ? true時の値 : false時の値
    // 大文字の場合は'A'、小文字の場合は'a'を基準とする
    char base = isupper(c) ? 'A' : 'a';

    // ===== シーザー暗号の核心的な計算 =====
    // この計算式でアルファベットの循環を実現
    
    // 1. (c - base): 文字を0-25の範囲に正規化
    //    例: 'A' - 'A' = 0, 'B' - 'A' = 1, 'Z' - 'A' = 25
    
    // 2. + n: 鍵の分だけずらす
    //    例: 1 + 3 = 4（B + 3 = E の位置）
    
    // 3. % 26: 26で割った余りを求めて循環を実現
    //    例: 25 + 3 = 28, 28 % 26 = 2（Z + 3 = C の位置）
    //    これにより、Zの次はAに戻る
    
    // 4. + base: 再びASCII文字コードに変換
    //    例: 2 + 'A' = 'C'
    
    return (c - base + n) % 26 + base;
}

// ===== プログラムの学習ポイント =====
/*
 * 1. 関数の分割: 機能ごとに関数を分けることで、コードの可読性と再利用性が向上
 * 
 * 2. エラーハンドリング: 不正な入力に対する適切な対応
 * 
 * 3. 文字コードの理解: ASCIIコードを活用した文字操作
 * 
 * 4. モジュラー演算: % 演算子を使った循環的な計算
 * 
 * 5. 条件分岐: if文や三項演算子を使った処理の分岐
 * 
 * 6. ループ処理: for文を使った繰り返し処理
 * 
 * 7. 文字列操作: C言語における文字列の扱い方
 */
