// ===== 多数決選挙プログラム（学習用詳細コメント版） =====
// このプログラムは、複数の候補者の中から最も多くの票を獲得した候補者を
// 勝者として決定する多数決選挙システムを実装したものです。

// ===== ヘッダーファイルのインクルード =====
#include <cs50.h>      // CS50ライブラリ（string型、get_string関数、get_int関数など）
#include <stdio.h>     // 標準入出力関数（printf など）
#include <string.h>    // 文字列操作関数（strcmp など）

// ===== 定数定義 =====
// #define: プリプロセッサディレクティブ（コンパイル前に文字列置換される）
// MAX: 最大候補者数を9人に制限（配列のサイズ制限）
#define MAX 9

// ===== 構造体定義 =====
// typedef struct: 新しいデータ型を定義
// candidate: 候補者の情報を格納する構造体
// 関連するデータ（名前と得票数）をまとめて管理することで、データの整合性を保つ
typedef struct
{
    string name;    // 候補者の名前（CS50のstring型）
    int votes;      // 候補者の得票数（整数型）
} candidate;

// ===== グローバル変数の定義 =====
// 関数間でデータを共有するための変数
// グローバル変数は全ての関数からアクセス可能
candidate candidates[MAX]; // 候補者の配列（最大9人分のメモリを確保）
int candidate_count;       // 実際の候補者数（実行時に決定される）

// ===== 関数プロトタイプ宣言 =====
// C言語では関数を使用する前にその存在を宣言する必要がある
// プロトタイプ宣言により、コンパイラが関数の存在と引数・戻り値の型を確認できる
bool vote(string name);     // 投票処理を行う関数（戻り値: 成功時true、失敗時false）
void print_winner(void);    // 勝者を表示する関数（戻り値なし、引数なし）

// ===== メイン関数 =====
// プログラムの実行開始点
// argc: コマンドライン引数の数, argv: コマンドライン引数の配列
int main(int argc, string argv[])
{
    // ===== 1. コマンドライン引数の検証 =====
    // ./plurality Alice Bob Charlie のように実行する
    // argc < 2 は候補者が1人もいないことを意味する
    // argc: プログラム名も含むため、候補者が1人でもargc=2になる
    if (argc < 2)
    {
        printf("Usage: plurality [candidate ...]\n");
        return 1; // エラーコード1で終了（標準的な異常終了コード）
    }

    // ===== 2. 候補者数の計算と検証 =====
    // argc - 1: プログラム名（argv[0]）を除いた引数の数 = 候補者数
    candidate_count = argc - 1;

    // 候補者数が配列の上限を超えていないかチェック
    // メモリオーバーフローを防ぐための重要な検証
    if (candidate_count > MAX)
    {
        printf("Maximum number of candidates is %i\n", MAX);
        return 2; // エラーコード2で終了（候補者数超過エラー）
    }

    // ===== 3. 候補者配列の初期化 =====
    // 各候補者の名前と得票数を初期設定
    for (int i = 0; i < candidate_count; i++)
    {
        // argv[i + 1]: argv[0]はプログラム名なので、候補者名はargv[1]から始まる
        candidates[i].name = argv[i + 1];  // 候補者名を設定
        candidates[i].votes = 0;           // 得票数を0で初期化（重要な初期化）
    }

    // ===== 4. 投票者数の取得 =====
    // get_int関数: ユーザーから整数を安全に取得（CS50ライブラリ）
    // 無効な入力（文字列など）が入力された場合は再入力を促す
    int voter_count = get_int("number of voters: ");

    // ===== 5. 投票処理のメインループ =====
    // 各投票者から投票を受け付ける
    for (int i = 0; i < voter_count; i++)
    {
        // 投票者から候補者名を取得
        // get_string関数: ユーザーから文字列を安全に取得
        string name = get_string("Vote: ");

        // vote関数で投票を処理
        // !vote(name): vote関数がfalseを返した場合（無効票）
        // 論理NOT演算子(!)でtrueに変換し、if文の条件として使用
        if (!vote(name))
        {
            printf("Invalid vote.\n");
            // 注意: 無効票でもループは継続（投票者数は変わらない）
        }
    }

    // ===== 6. 選挙結果の表示 =====
    print_winner();

    return 0; // 正常終了（成功を示すコード0）
}

// ===== 投票処理関数 =====

bool vote(string name)
{
    // ===== 線形探索による候補者の検索 =====
    // 全候補者を順番に確認（O(n)の時間複雑度）
    for (int i = 0; i < candidate_count; i++)
    {
        // ===== 文字列比較による候補者の特定 =====
        // strcmp関数: 2つの文字列を辞書順で比較
        // 戻り値: 0=完全一致, 負数=第1引数が小さい, 正数=第1引数が大きい
        // == 0 で完全一致を判定
        if (strcmp(name, candidates[i].name) == 0)
        {
            // 該当する候補者の得票数を1増やす
            // ++演算子でインクリメント
            candidates[i].votes++;
            
            // 投票が成功したのでtrueを返して関数終了
            return true;
        }
    }
    
    // ここまで到達した場合、該当する候補者がいない（無効票）
    // for文を抜けても一致する候補者がいなかった
    return false;
}

// ===== 勝者表示関数 =====
/**
 * @brief 選挙の勝者（最高得票者）を表示する
 * @param void 引数なし
 * @return なし
 * 
 * この関数の重要な処理:
 * 1. 最大値探索アルゴリズムで最高得票数を発見
 * 2. 最高得票数を持つ全候補者を表示（引き分け対応）
 * 3. 2段階処理により効率的な勝者判定を実現
 */
void print_winner(void)
{
    // ===== 段階1: 最高得票数を見つける =====
    // 最大値探索アルゴリズム（O(n)の時間複雑度）
    int max_votes = 0; // 最高得票数を記録する変数（0で初期化）
    
    // 全候補者の得票数を順番に確認
    for (int i = 0; i < candidate_count; i++)
    {
        // 現在の候補者の得票数が記録されている最高得票数より多い場合
        if (candidates[i].votes > max_votes)
        {
            max_votes = candidates[i].votes; // 最高得票数を更新
        }
    }
    
    // この時点で max_votes には最高得票数が格納されている

    // ===== 段階2: 最高得票数を持つ候補者を表示 =====
    // 同数で勝者が複数いる可能性があるため、全候補者を再度確認
    // 引き分けの場合は複数の勝者が表示される
    for (int i = 0; i < candidate_count; i++)
    {
        // 候補者の得票数が最高得票数と同じ場合
        if (candidates[i].votes == max_votes)
        {
            printf("%s\n", candidates[i].name); // 勝者の名前を表示
        }
    }
    
    // return文は省略可能（void関数では自動的に関数終了）
    return;
}

// ===== プログラムの学習ポイント =====
/*
 * 1. 構造体の活用:
 *    - 関連するデータ（名前と得票数）をまとめて管理
 *    - typedef を使った新しいデータ型の定義
 *    - データの整合性を保つ設計
 * 
 * 2. 配列とループの効率的な使用:
 *    - 複数の候補者データを配列で管理
 *    - for文を使った繰り返し処理
 *    - 線形探索アルゴリズムの実装
 * 
 * 3. 文字列操作:
 *    - strcmp関数を使った文字列比較
 *    - C言語における文字列の扱い方
 *    - 大文字小文字の区別（完全一致が必要）
 * 
 * 4. 関数設計の原則:
 *    - 機能ごとに関数を分割（単一責任原則）
 *    - 戻り値を使った処理結果の通知
 *    - 関数の独立性と再利用性
 * 
 * 5. エラーハンドリング:
 *    - 不正な入力に対する適切な対応
 *    - 複数のエラーコードによる異なる終了状態
 *    - 境界値チェック（配列のサイズ制限）
 * 
 * 6. アルゴリズムの理解:
 *    - 最大値探索アルゴリズム
 *    - 線形探索アルゴリズム
 *    - 2段階処理による効率化
 * 
 * 7. メモリ管理:
 *    - 静的配列の使用
 *    - グローバル変数の適切な使用
 *    - 初期化の重要性
 * 
 * 8. 実世界の問題解決:
 *    - 選挙システムという実際の問題をプログラムで解決
 *    - 引き分けの処理など、現実的な状況への対応
 *    - ユーザーインターフェースの設計
 * 
 * 9. プログラムの実行例:
 *    $ ./plurality Alice Bob Charlie
 *    number of voters: 3
 *    Vote: Alice
 *    Vote: Bob  
 *    Vote: Alice
 *    Alice
 * 
 * 10. 考えられる改善点:
 *     - 大文字小文字を区別しない比較
 *     - 候補者名の重複チェック
 *     - 動的メモリ割り当ての使用
 *     - より詳細な投票結果の表示
 */
